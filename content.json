{"pages":[],"posts":[{"title":"瓯网杯easyeasy","text":"##静态分析 出现Failed提示框 ###然后我们打开IDA，字符串搜索Filed 发现上面还有成功的字样ctrl+x查看，发现就一个跳转到这里跳转就在上面判断的函数就在上面然后我们F5查看一下 这里是一个调用函数 这里是一个异或加密，加密的库是在上面 加密的数据应该在调用的函数里面我们点进去看看发现里面有位移和与或的操作判断又是一层加密我们浏览一下其他函数 这里判断输入数据的长度如果等于22则调用刚刚第一次的函数，否则弹窗提示错误初步判断输入值是22位，然后通过第一次加密，得到的数据再进行一次异或加密，得到的数据与固定的字符串做对比，如果正确就返回1，弹出成功提示下面我们通过OD具体调试一下 ##动态调试我们在IDA第一次加密函数的地方按tab键 看到Push ebp 就是函数的开始1.记下地址16F0然后再OD中ctrl+g定位到16F0处，F2设置断点。2.F9运行程序3.在输入框中输入22位字符串（我这边输入的是123456789abcdef1234567）4.然后就是最重要的调试了 00B516F0 /$ 55 push ebp 00B516F1 |. 8BEC mov ebp,esp 00B516F3 |. 83EC 1C sub esp,0x1C 00B516F6 |. C745 F4 00000&gt;mov [local.3],0x0 ; v7 00B516FD |. C745 F8 00000&gt;mov [local.2],0x0 ; v8 00B51704 |. C645 FF 00 mov byte ptr ss:[ebp-0x1],0x0 00B51708 |. 8B45 08 mov eax,[arg.1] 00B5170B |. 8945 F0 mov [local.4],eax 00B5170E |. 8B4D F0 mov ecx,[local.4] 00B51711 |. 83C1 01 add ecx,0x1 00B51714 |. 894D E8 mov [local.6],ecx 00B51717 |&gt; 8B55 F0 /mov edx,[local.4] 00B5171A |. 8A02 |mov al,byte ptr ds:[edx] 00B5171C |. 8845 FE |mov byte ptr ss:[ebp-0x2],al 00B5171F |. 8345 F0 01 |add [local.4],0x1 00B51723 |. 807D FE 00 |cmp byte ptr ss:[ebp-0x2],0x0 00B51727 |.^ 75 EE \\jnz short EasyEasy.00B51717 ; 循环读取输入值长度 00B51729 |. 8B4D F0 mov ecx,[local.4] ; 006ff8eb 00B5172C |. 2B4D E8 sub ecx,[local.6] ; 0x6ff8eb-0x6ff8d5=0x16=22 00B5172F |. 894D E4 mov [local.7],ecx 00B51732 |. 8B55 E4 mov edx,[local.7] 00B51735 |. 8955 EC mov [local.5],edx ; v6=len(a1)=22 00B51738 |. EB 09 jmp short EasyEasy.00B51743 00B5173A |&gt; 8B45 F4 /mov eax,[local.3] 00B5173D |. 83C0 03 |add eax,0x3 00B51740 |. 8945 F4 |mov [local.3],eax 00B51743 |&gt; 8B4D F4 mov ecx,[local.3] 00B51746 |. 3B4D EC |cmp ecx,[local.5] ; cmp 0,0x16 while循环 ecx=0,3,6,9 00B51749 |. 0F8D 95010000 |jge EasyEasy.00B518E4 ; 跳出循环 00B5174F |. 8B55 08 |mov edx,[arg.1] 00B51752 |. 0355 F4 |add edx,[local.3] 00B51755 |. 0FB602 |movzx eax,byte ptr ds:[edx] ; eax=0x31(&apos;1&apos;) 34(&apos;4&apos;),37(&apos;7&apos;),61(&apos;a&apos;) 00B51758 |. C1F8 02 |sar eax,0x2 ; 二进制右移两位 eax=0xc,0xd,0x18 00B5175B |. 83E0 3F |and eax,0x3F 00B5175E |. 8845 FF |mov byte ptr ss:[ebp-0x1],al ; al=0x0c,0x0D,0x0D,0x18 00B51761 |. 0FB64D FF |movzx ecx,byte ptr ss:[ebp-0x1] 00B51765 |. 8B55 0C |mov edx,[arg.2] 00B51768 |. 0355 F8 |add edx,[local.2] 00B5176B |. A1 E040B500 |mov eax,dword ptr ds:[0xB540E0] 00B51770 |. 8A0C08 |mov cl,byte ptr ds:[eax+ecx] ; 6E(&apos;n&apos;) 57(&apos;W&apos;)57(&apos;W&apos;)6C(&apos;l&apos;) 00B51773 |. 880A |mov byte ptr ds:[edx],cl 00B51775 |. 8B55 F8 |mov edx,[local.2] 00B51778 |. 83C2 01 |add edx,0x1 ; 0+0x1 00B5177B |. 8955 F8 |mov [local.2],edx ; v8=1,5,9,D 00B5177E |. 8B45 08 |mov eax,[arg.1] 00B51781 |. 0345 F4 |add eax,[local.3] 00B51784 |. 0FB608 |movzx ecx,byte ptr ds:[eax] ; ecx=0x31(&apos;1&apos;),34(&apos;4&apos;),37(&apos;7&apos;),61(&apos;a&apos;) 00B51787 |. C1E1 04 |shl ecx,0x4 ; 左移4位 ecx=0x310,0x340,0x370,0x610 00B5178A |. 83E1 30 |and ecx,0x30 ; 0x310 and 0x30 =0x10, 0x0,0x30,0x10 00B5178D |. 884D FF |mov byte ptr ss:[ebp-0x1],cl 00B51790 |. 8B55 F4 |mov edx,[local.3] ; 0,3,6 00B51793 |. 83C2 01 |add edx,0x1 ; 1,4,7,A 00B51796 |. 3B55 EC |cmp edx,[local.5] ; cmp 0x1,0x16 00B51799 |. 7D 39 |jge short EasyEasy.00B517D4 ; 循环结束后跳转 v7&gt;=0x16时 00B5179B |. 8B45 08 |mov eax,[arg.1] 00B5179E |. 0345 F4 |add eax,[local.3] 00B517A1 |. 0FB648 01 |movzx ecx,byte ptr ds:[eax+0x1] ; ecx=32(&apos;2&apos;),5,8,b 00B517A5 |. C1F9 04 |sar ecx,0x4 ; 右移4位 ecx=0x3,0x3,0x3,0x6 00B517A8 |. 83E1 0F |and ecx,0xF ; 0x3and0xf=0x3,0x3,0x3,0x6 00B517AB |. 0FB655 FF |movzx edx,byte ptr ss:[ebp-0x1] ; 0x10,0x0,0x30,0x10 00B517AF |. 0BD1 |or edx,ecx ; 0x13,3,33,16 00B517B1 |. 8855 FF |mov byte ptr ss:[ebp-0x1],dl ; 0x13,0x3,0x33,0x16 00B517B4 |. 0FB645 FF |movzx eax,byte ptr ss:[ebp-0x1] 00B517B8 |. 8B4D 0C |mov ecx,[arg.2] ; 0x006ff7ec 00B517BB |. 034D F8 |add ecx,[local.2] 00B517BE |. 8B15 E040B500 |mov edx,dword ptr ds:[0xB540E0] ; ds:[00B540E0]=00B54018 (EasyEasy.00B54018), ASCII 52,&quot;9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U&quot; 00B517C4 |. 8A0402 |mov al,byte ptr ds:[edx+eax] ; al=48(&apos;H&apos;),79(&apos;y&apos;),46(&apos;F&apos;),53(&apos;S&apos;) 00B517C7 |. 8801 |mov byte ptr ds:[ecx],al 00B517C9 |. 8B4D F8 |mov ecx,[local.2] ; 1 00B517CC |. 83C1 01 |add ecx,0x1 ; 1+1 00B517CF |. 894D F8 |mov [local.2],ecx ; v8=2,6,A 00B517D2 |. EB 51 |jmp short EasyEasy.00B51825 00B517D4 |&gt; 0FB655 FF |movzx edx,byte ptr ss:[ebp-0x1] ; ----------循环结束后跳到这里--------------------- 00B517D8 |. 8B45 0C |mov eax,[arg.2] ; 006ff7ec 00B517DB |. 0345 F8 |add eax,[local.2] ; 1D 006ff809 00B517DE |. 8B0D E040B500 |mov ecx,dword ptr ds:[0xB540E0] ; EasyEasy.00B54018 00B517E4 |. 8A1411 |mov dl,byte ptr ds:[ecx+edx] ; 7A(&apos;z&apos;) 00B517E7 |. 8810 |mov byte ptr ds:[eax],dl 00B517E9 |. 8B45 F8 |mov eax,[local.2] ; 1D 00B517EC |. 83C0 01 |add eax,0x1 00B517EF |. 8945 F8 |mov [local.2],eax ; v8=1E 00B517F2 |. 8B4D 0C |mov ecx,[arg.2] 00B517F5 |. 034D F8 |add ecx,[local.2] ; 006ff80A 00B517F8 |. 8A15 6031B500 |mov dl,byte ptr ds:[0xB53160] ; dl=40[@] 00B517FE |. 8811 |mov byte ptr ds:[ecx],dl 00B51800 |. 8B45 F8 |mov eax,[local.2] 00B51803 |. 83C0 01 |add eax,0x1 00B51806 |. 8945 F8 |mov [local.2],eax ; v8=1F 00B51809 |. 8B4D 0C |mov ecx,[arg.2] ; 堆栈 ss:[006FF7A4]=006FF7EC, (ASCII &quot;nHvFWyefWFZilSs1+o4wnHvFWyefWz@&quot;) 00B5180C |. 034D F8 |add ecx,[local.2] 00B5180F |. 8A15 6031B500 |mov dl,byte ptr ds:[0xB53160] 00B51815 |. 8811 |mov byte ptr ds:[ecx],dl 00B51817 |. 8B45 F8 |mov eax,[local.2] 00B5181A |. 83C0 01 |add eax,0x1 00B5181D |. 8945 F8 |mov [local.2],eax ; v8=20 00B51820 |. E9 BF000000 |jmp EasyEasy.00B518E4 ; break 00B51825 |&gt; 8B4D 08 |mov ecx,[arg.1] ; ------------------------------------- 00B51828 |. 034D F4 |add ecx,[local.3] 00B5182B |. 0FB651 01 |movzx edx,byte ptr ds:[ecx+0x1] ; edx=32(&apos;2&apos;),35(&apos;5&apos;),38(&apos;8&apos;) 00B5182F |. C1E2 02 |shl edx,0x2 ; 左移两位 C8,D4,E0 00B51832 |. 83E2 3C |and edx,0x3C ; 8,14,20 00B51835 |. 8855 FF |mov byte ptr ss:[ebp-0x1],dl ; dl=08,14,20 00B51838 |. 8B45 F4 |mov eax,[local.3] 00B5183B |. 83C0 02 |add eax,0x2 ; 0x2,0x5,0x8 00B5183E |. 3B45 EC |cmp eax,[local.5] ; cmp0x2,0x16 00B51841 |. 7D 66 |jge short EasyEasy.00B518A9 00B51843 |. 8B4D 08 |mov ecx,[arg.1] 00B51846 |. 034D F4 |add ecx,[local.3] 00B51849 |. 0FB651 02 |movzx edx,byte ptr ds:[ecx+0x2] ; edx=33(&apos;3&apos;),36(&apos;6&apos;),39(&apos;9&apos;) 00B5184D |. C1FA 06 |sar edx,0x6 ; 右移6位 0,0,0 00B51850 |. 83E2 03 |and edx,0x3 ; 0,0,0 00B51853 |. 0FB645 FF |movzx eax,byte ptr ss:[ebp-0x1] ; 08,14,20 00B51857 |. 0BC2 |or eax,edx ; 8,14,20 00B51859 |. 8845 FF |mov byte ptr ss:[ebp-0x1],al 00B5185C |. 0FB64D FF |movzx ecx,byte ptr ss:[ebp-0x1] ; ecx=0x8,0x14,0x20 00B51860 |. 8B55 0C |mov edx,[arg.2] 00B51863 |. 0355 F8 |add edx,[local.2] ; v8=2,6,A 00B51866 |. A1 E040B500 |mov eax,dword ptr ds:[0xB540E0] ; 00b54018 00B5186B |. 8A0C08 |mov cl,byte ptr ds:[eax+ecx] ; cl=76(&apos;v&apos;),65(&apos;e&apos;),5A(&apos;Z&apos;) 00B5186E |. 880A |mov byte ptr ds:[edx],cl 00B51870 |. 8B55 F8 |mov edx,[local.2] ; 2 00B51873 |. 83C2 01 |add edx,0x1 ; 2+1 00B51876 |. 8955 F8 |mov [local.2],edx ; v8=3,7,B 00B51879 |. 8B45 08 |mov eax,[arg.1] 00B5187C |. 0345 F4 |add eax,[local.3] ; 0,3,6 00B5187F |. 0FB648 02 |movzx ecx,byte ptr ds:[eax+0x2] ; ecx=33(&apos;3&apos;),36(&apos;6&apos;),39(&apos;9&apos;) 00B51883 |. 83E1 3F |and ecx,0x3F ; 33,36 00B51886 |. 884D FF |mov byte ptr ss:[ebp-0x1],cl ; cl=33(&apos;3&apos;),36(&apos;6&apos;),39(&apos;9&apos;) 00B51889 |. 0FB655 FF |movzx edx,byte ptr ss:[ebp-0x1] 00B5188D |. 8B45 0C |mov eax,[arg.2] 00B51890 |. 0345 F8 |add eax,[local.2] ; v8=3,7,B 00B51893 |. 8B0D E040B500 |mov ecx,dword ptr ds:[0xB540E0] ; EasyEasy.00B54018 00B51899 |. 8A1411 |mov dl,byte ptr ds:[ecx+edx] ; dl=46(&apos;F&apos;),66(&apos;f&apos;),69(&apos;i&apos;) 00B5189C |. 8810 |mov byte ptr ds:[eax],dl 00B5189E |. 8B45 F8 |mov eax,[local.2] ; v8=3 00B518A1 |. 83C0 01 |add eax,0x1 ; 3+1 00B518A4 |. 8945 F8 |mov [local.2],eax ; v8=4,8,C 00B518A7 |. EB 36 |jmp short EasyEasy.00B518DF ; 向下跳转继续循环 00B518A9 |&gt; 0FB64D FF |movzx ecx,byte ptr ss:[ebp-0x1] 00B518AD |. 8B55 0C |mov edx,[arg.2] 00B518B0 |. 0355 F8 |add edx,[local.2] 00B518B3 |. A1 E040B500 |mov eax,dword ptr ds:[0xB540E0] 00B518B8 |. 8A0C08 |mov cl,byte ptr ds:[eax+ecx] 00B518BB |. 880A |mov byte ptr ds:[edx],cl 00B518BD |. 8B55 F8 |mov edx,[local.2] 00B518C0 |. 83C2 01 |add edx,0x1 00B518C3 |. 8955 F8 |mov [local.2],edx 00B518C6 |. 8B45 0C |mov eax,[arg.2] 00B518C9 |. 0345 F8 |add eax,[local.2] 00B518CC |. 8A0D 6031B500 |mov cl,byte ptr ds:[0xB53160] 00B518D2 |. 8808 |mov byte ptr ds:[eax],cl 00B518D4 |. 8B55 F8 |mov edx,[local.2] 00B518D7 |. 83C2 01 |add edx,0x1 00B518DA |. 8955 F8 |mov [local.2],edx 00B518DD |. EB 05 |jmp short EasyEasy.00B518E4 ; break 00B518DF |&gt;^ E9 56FEFFFF \\jmp EasyEasy.00B5173A 00B518E4 |&gt; 8B45 0C mov eax,[arg.2] 00B518E7 |. 0345 F8 add eax,[local.2] 00B518EA |. C600 00 mov byte ptr ds:[eax],0x0 00B518ED |. 33C0 xor eax,eax 00B518EF |. 8BE5 mov esp,ebp 00B518F1 |. 5D pop ebp 00B518F2 \\. C3 retn 这一个循环比较长，我用”,”逗号隔开的是循环第二轮得到的数在这个循环中我们看到他是通过下面这个字符串加密的 “9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U” 然后最后把我输入的123456789abcdef1234567加密后得到的结果是 nHvFWyefWFZilSs1+o4wnHvFWyefWz@ 然后返回给上一个函数做第二次加密下面是我根据这个加密过程写出来的python脚本 a1 = &quot;123456789abcdef1234567&quot; #raw_input(&quot;请输入22位字符串》》&quot;) s = &quot;R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U&quot; r1 = [&apos;&apos;]*100 j = 0 #v8 for i in range(0,22,3): #i=v7 i2 = i if i2 &lt; 0x16: x = (ord(a1[i])&gt;&gt;2) &amp; 63 r1[j] = s[x] print r1 j += 1 x=(ord(a1[i])&lt;&lt;4) &amp; 48 i2 = i + 1 if i2 &lt; 0x16: y = ((ord(a1[i+1])&gt;&gt;4) &amp; 15) | x r1[j] = s[y] print r1 j += 1 x = (ord(a1[i+1])&lt;&lt;2) &amp; 60 i2 = i + 2 if i2 &lt; 0x16: n = ord(a1[i+2]) y = ((n&gt;&gt;6) &amp; 3) | x r1[j] = s[y] print r1 j += 1 x = n &amp; 63 r1[j] = s[x] print r1 j +=1 else: r1[j]=s[x] j += 1 r1[j] = &apos;@&apos; j += 1 break else: r1[j]=s[x] j += 1 r1[j] = &apos;@&apos; j += 1 r1[j] = &apos;@&apos; j += 1 break else: break print &quot;&quot;.join(r1) 我们继续想下调试，他返回到了上一个函数中，然后做第二次加密 00B5140E |. E8 DD020000 call EasyEasy.00B516F0 00B51413 |. 83C4 08 add esp,0x8 00B51416 |. C645 D4 00 mov byte ptr ss:[ebp-0x2C],0x0 00B5141A |. 6A 27 push 0x27 ; /n = 27 (39.) 00B5141C |. 6A 00 push 0x0 ; |c = 00 00B5141E |. 8D55 D5 lea edx,dword ptr ss:[ebp-0x2B] ; | 00B51421 |. 52 push edx ; |s = 0000001F 00B51422 |. E8 2D0E0000 call &lt;jmp.&amp;MSVCR120.memset&gt; ; \\memset 00B51427 |. 83C4 0C add esp,0xC 00B5142A |. C685 30FFFFFF&gt;mov byte ptr ss:[ebp-0xD0],0x57 00B51431 |. C685 31FFFFFF&gt;mov byte ptr ss:[ebp-0xCF],0x4D 00B51438 |. C685 32FFFFFF&gt;mov byte ptr ss:[ebp-0xCE],0x4E 00B5143F |. C685 33FFFFFF&gt;mov byte ptr ss:[ebp-0xCD],0x5E 00B51446 |. C685 34FFFFFF&gt;mov byte ptr ss:[ebp-0xCC],0x4B 00B5144D |. C685 35FFFFFF&gt;mov byte ptr ss:[ebp-0xCB],0x5A 00B51454 |. C685 36FFFFFF&gt;mov byte ptr ss:[ebp-0xCA],0x51 00B5145B |. C685 37FFFFFF&gt;mov byte ptr ss:[ebp-0xC9],0x55 00B51462 |. C685 38FFFFFF&gt;mov byte ptr ss:[ebp-0xC8],0x5D 00B51469 |. C685 39FFFFFF&gt;mov byte ptr ss:[ebp-0xC7],0x5E 00B51470 |. C685 3AFFFFFF&gt;mov byte ptr ss:[ebp-0xC6],0x5F 00B51477 |. C685 3BFFFFFF&gt;mov byte ptr ss:[ebp-0xC5],0x51 00B5147E |. C685 3CFFFFFF&gt;mov byte ptr ss:[ebp-0xC4],0x5C 00B51485 |. C685 3DFFFFFF&gt;mov byte ptr ss:[ebp-0xC3],0x4D 00B5148C |. C685 3EFFFFFF&gt;mov byte ptr ss:[ebp-0xC2],0x58 00B51493 |. C685 3FFFFFFF&gt;mov byte ptr ss:[ebp-0xC1],0x5F 00B5149A |. C685 40FFFFFF&gt;mov byte ptr ss:[ebp-0xC0],0x57 00B514A1 |. C685 41FFFFFF&gt;mov byte ptr ss:[ebp-0xBF],0x54 00B514A8 |. C685 42FFFFFF&gt;mov byte ptr ss:[ebp-0xBE],0x5D 00B514AF |. C685 43FFFFFF&gt;mov byte ptr ss:[ebp-0xBD],0x58 00B514B6 |. C685 44FFFFFF&gt;mov byte ptr ss:[ebp-0xBC],0x59 00B514BD |. C685 45FFFFFF&gt;mov byte ptr ss:[ebp-0xBB],0x59 00B514C4 |. C685 46FFFFFF&gt;mov byte ptr ss:[ebp-0xBA],0x58 00B514CB |. C685 47FFFFFF&gt;mov byte ptr ss:[ebp-0xB9],0x5F 00B514D2 |. C685 48FFFFFF&gt;mov byte ptr ss:[ebp-0xB8],0x5B 00B514D9 |. C685 49FFFFFF&gt;mov byte ptr ss:[ebp-0xB7],0x58 00B514E0 |. C685 4AFFFFFF&gt;mov byte ptr ss:[ebp-0xB6],0x5F 00B514E7 |. C685 4BFFFFFF&gt;mov byte ptr ss:[ebp-0xB5],0x5B 00B514EE |. C685 4CFFFFFF&gt;mov byte ptr ss:[ebp-0xB4],0x5D 00B514F5 |. C685 4DFFFFFF&gt;mov byte ptr ss:[ebp-0xB3],0x4C 00B514FC |. C685 4EFFFFFF&gt;mov byte ptr ss:[ebp-0xB2],0x52 00B51503 |. C685 4FFFFFFF&gt;mov byte ptr ss:[ebp-0xB1],0x5F 00B5150A |. C685 10FFFFFF&gt;mov byte ptr ss:[ebp-0xF0],0x6D 00B51511 |. C685 11FFFFFF&gt;mov byte ptr ss:[ebp-0xEF],0x6C 00B51518 |. C685 12FFFFFF&gt;mov byte ptr ss:[ebp-0xEE],0x3A 00B5151F |. C685 13FFFFFF&gt;mov byte ptr ss:[ebp-0xED],0x7A 00B51526 |. C685 14FFFFFF&gt;mov byte ptr ss:[ebp-0xEC],0x1D 00B5152D |. C685 15FFFFFF&gt;mov byte ptr ss:[ebp-0xEB],0x4F 00B51534 |. C685 16FFFFFF&gt;mov byte ptr ss:[ebp-0xEA],0x8A 00B5153B |. C685 17FFFFFF&gt;mov byte ptr ss:[ebp-0xE9],0x7F 00B51542 |. C685 18FFFFFF&gt;mov byte ptr ss:[ebp-0xE8],0xB8 00B51549 |. C685 19FFFFFF&gt;mov byte ptr ss:[ebp-0xE7],0x4A 00B51550 |. C685 1AFFFFFF&gt;mov byte ptr ss:[ebp-0xE6],0x57 00B51557 |. C685 1BFFFFFF&gt;mov byte ptr ss:[ebp-0xE5],0x13 00B5155E |. C685 1CFFFFFF&gt;mov byte ptr ss:[ebp-0xE4],0x2F 00B51565 |. C685 1DFFFFFF&gt;mov byte ptr ss:[ebp-0xE3],0xA7 00B5156C |. C685 1EFFFFFF&gt;mov byte ptr ss:[ebp-0xE2],0x63 00B51573 |. C685 1FFFFFFF&gt;mov byte ptr ss:[ebp-0xE1],0xBA 00B5157A |. C685 20FFFFFF&gt;mov byte ptr ss:[ebp-0xE0],0xC5 00B51581 |. C685 21FFFFFF&gt;mov byte ptr ss:[ebp-0xDF],0xAA 00B51588 |. C685 22FFFFFF&gt;mov byte ptr ss:[ebp-0xDE],0x65 00B5158F |. C685 23FFFFFF&gt;mov byte ptr ss:[ebp-0xDD],0x99 00B51596 |. C685 24FFFFFF&gt;mov byte ptr ss:[ebp-0xDC],0xDF 00B5159D |. C685 25FFFFFF&gt;mov byte ptr ss:[ebp-0xDB],0x58 00B515A4 |. C685 26FFFFFF&gt;mov byte ptr ss:[ebp-0xDA],0xF5 00B515AB |. C685 27FFFFFF&gt;mov byte ptr ss:[ebp-0xD9],0x54 00B515B2 |. C685 28FFFFFF&gt;mov byte ptr ss:[ebp-0xD8],0x46 00B515B9 |. C685 29FFFFFF&gt;mov byte ptr ss:[ebp-0xD7],0xAB 00B515C0 |. C685 2AFFFFFF&gt;mov byte ptr ss:[ebp-0xD6],0xB2 00B515C7 |. C685 2BFFFFFF&gt;mov byte ptr ss:[ebp-0xD5],0xA0 00B515CE |. C685 2CFFFFFF&gt;mov byte ptr ss:[ebp-0xD4],0x31 00B515D5 |. C685 2DFFFFFF&gt;mov byte ptr ss:[ebp-0xD3],0xC0 00B515DC |. C685 2EFFFFFF&gt;mov byte ptr ss:[ebp-0xD2],0xEB 00B515E3 |. C685 2FFFFFFF&gt;mov byte ptr ss:[ebp-0xD1],0x38 00B515EA |. C785 50FFFFFF&gt;mov [local.44],0x0 00B515F4 |. EB 0F jmp short EasyEasy.00B51605 00B515F6 |&gt; 8B85 50FFFFFF /mov eax,[local.44] 00B515FC |. 83C0 01 |add eax,0x1 00B515FF |. 8985 50FFFFFF |mov [local.44],eax ; 1,2,3 00B51605 |&gt; 83BD 50FFFFFF&gt; cmp [local.44],0x20 00B5160C |. 0F8D 90000000 |jge EasyEasy.00B516A2 00B51612 |. 8B8D 50FFFFFF |mov ecx,[local.44] ; 0,1,2,3 00B51618 |. 0FBE940D 54FF&gt;|movsx edx,byte ptr ss:[ebp+ecx-0xAC] ; 6E(&apos;n&apos;),48(&apos;H&apos;),76(&apos;v&apos;),46(&apos;F&apos;) 00B51620 |. 8B85 50FFFFFF |mov eax,[local.44] ; 0,1,2,3 00B51626 |. 0FBE8C05 10FF&gt;|movsx ecx,byte ptr ss:[ebp+eax-0xF0] ; 6D(&apos;m&apos;),6C(&apos;l&apos;),3A(&apos;:&apos;),7A(&apos;z&apos;) 00B5162E |. 33D1 |xor edx,ecx ; 3,24,4C,3C 00B51630 |. 8B85 50FFFFFF |mov eax,[local.44] ; 0,1,2,3 00B51636 |. 885405 D4 |mov byte ptr ss:[ebp+eax-0x2C],dl ; 0x3,0x24,0x4C(&apos;L&apos;),3C(&apos;&lt;&apos;) 00B5163A |. 8B8D 50FFFFFF |mov ecx,[local.44] ; 0,1,2,3 00B51640 |. 81E1 01000080 |and ecx,0x80000001 ; 0,1,0,1 00B51646 |. 79 05 |jns short EasyEasy.00B5164D 00B51648 |. 49 |dec ecx 00B51649 |. 83C9 FE |or ecx,-0x2 00B5164C |. 41 |inc ecx 00B5164D |&gt; 85C9 |test ecx,ecx 00B5164F |. 75 27 |jnz short EasyEasy.00B51678 ; 第一次未实现，第二次实现,第三次未实现 ecx=1时跳转 00B51651 |. 8B95 50FFFFFF |mov edx,[local.44] 00B51657 |. 0FBE8415 30FF&gt;|movsx eax,byte ptr ss:[ebp+edx-0xD0] ; 57(&apos;W&apos;),4E(&apos;N&apos;) 00B5165F |. 8B8D 50FFFFFF |mov ecx,[local.44] 00B51665 |. 0FBE540D D4 |movsx edx,byte ptr ss:[ebp+ecx-0x2C] ; 03,4C(&apos;L&apos;) 00B5166A |. 2BD0 |sub edx,eax ; 0x03-0x57=0xffffffac ,fffffffe 00B5166C |. 8B85 50FFFFFF |mov eax,[local.44] 00B51672 |. 885405 D4 |mov byte ptr ss:[ebp+eax-0x2C],dl ; AC,FE 00B51676 |. EB 25 |jmp short EasyEasy.00B5169D 00B51678 |&gt; 8B8D 50FFFFFF |mov ecx,[local.44] ; jnz跳转到此处 00B5167E |. 0FBE940D 30FF&gt;|movsx edx,byte ptr ss:[ebp+ecx-0xD0] ; 4D(&apos;M&apos;),5E(&apos;^&apos;) 00B51686 |. 8B85 50FFFFFF |mov eax,[local.44] 00B5168C |. 0FBE4C05 D4 |movsx ecx,byte ptr ss:[ebp+eax-0x2C] ; 24(&apos;$&apos;),3C(&apos;&lt;&apos;) 00B51691 |. 03CA |add ecx,edx ; 0x71,0x9A 00B51693 |. 8B95 50FFFFFF |mov edx,[local.44] 00B51699 |. 884C15 D4 |mov byte ptr ss:[ebp+edx-0x2C],cl ; 71(&apos;q&apos;),9A 00B5169D |&gt;^ E9 54FFFFFF \\jmp EasyEasy.00B515F6 00B516A2 |&gt; 8D45 D4 lea eax,[local.11] 00B516A5 |. 50 push eax 00B516A6 |. E8 55020000 call EasyEasy.00B51900 00B516AB |. 83C4 04 add esp,0x4 00B516AE |. 83F8 01 cmp eax,0x1 00B516B1 75 16 jnz short EasyEasy.00B516C9 00B516B3 |. 6A 40 push 0x40 ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL 00B516B5 |. 68 A840B500 push EasyEasy.00B540A8 ; |Title = &quot;Success&quot; 00B516BA |. 68 B040B500 push EasyEasy.00B540B0 ; |Text = &quot;Congratulations!&quot; 00B516BF |. 6A 00 push 0x0 ; |hOwner = NULL 00B516C1 |. FF15 D030B500 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \\MessageBoxA 00B516C7 |. EB 14 jmp short EasyEasy.00B516DD 00B516C9 |&gt; 6A 40 push 0x40 ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL 00B516CB |. 68 C440B500 push EasyEasy.00B540C4 ; |Title = &quot;Erros&quot; 00B516D0 |. 68 CC40B500 push EasyEasy.00B540CC ; |Text = &quot;Failed!&quot; 00B516D5 |. 6A 00 push 0x0 ; |hOwner = NULL 00B516D7 |. FF15 D030B500 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \\MessageBoxA 地址00B5150A-00B515E3是第一次异或运算所用到的数据 地址00B5142A-00B51503是做第二次加减运算所用到的数据 它的加密过程是，拿上一次加密得到的32位字符串，和地址00B5150A-00B515E3的32位字符做异或运算，然后拿[local.44]就是伪C中出现的0x68他循环结果就是“0-21” 与0x80000001做与运算得到的结果其实只有0和1，如果是0，就做一次减运算与00B5142A-00B51503中的数据，如果是1则做加运算 加密完成后进入00B516A6 call EasyEasy.00B51900 ，进行字符串比对，如果比对成功返回success 下面是第二个加密的逆向脚本脚本 #!/usr/bin/python # coding=utf-8 s = [0xEF,0x68,0x14,0x68,0xEB,0x91,0x74,0x83, #最终比对的字符串 0x77,0x6A,0xC2,0xA2,0xA8,0x41,0xDC,0x30, 0x54,0x4D,0xAE,0x30,0x2F,0xC2,0x41,0x75, 0xCD,0x34,0x7F,0x33,0xF3,0xE0,0x59,0xD7] c1 = [0x6D,0x6C,0x3A,0x7A,0x1D,0x4F,0x8A,0x7F, #加密字符串1 0xB8,0x4A,0x57,0x13,0x2F,0xA7,0x63,0xBA, 0xC5,0xAA,0x65,0x99,0xDF,0x58,0xF5,0x54, 0x46,0xAB,0xB2,0xA0,0x31,0xC0,0xEB,0x38] c2 = [0x57,0x4D,0x4E,0x5E,0x4B,0x5A,0x51,0x55, #加密字符串2 0x5D,0x5E,0x5F,0x51,0x5C,0x4D,0x58,0x5F, 0x57,0x54,0x5D,0x58,0x59,0x59,0x58,0x5F, 0x5B,0x58,0x5F,0x5B,0x5D,0x4C,0x52,0x5F] a = [&apos;&apos;]*100 for i in range(0,32): if i%2==0: a[i] = chr((s[i] + c2[i])%256^c1[i]) else: a[i] = (s[i] - c2[i]) ^ c1[i] if a[i]&lt;0: a[i] +=256 a[i] = chr(a[i]) b = &quot;&quot;.join(a) print b 由于第一个加密用的是不可逆的与或运算，因此我们需要通过爆破逆出flag #!/usr/bin/python # coding=utf-8 #a1 = &quot;123456789abcdef1234567&quot; #OD调试时用的值 #nHvFWyefWFZilSs1+o4wnHvFWyefWz@@ #测试的结果值 s = &quot;R9Ly6NoJvsIPnWhETYtHe4Sdl+MbGujaZpk102wKCr7/ODg5zXAFqQfxBicV3m8U&quot;#加密时作为比对的字符串 r1 = [&apos;&apos;]*100 #输入的flag通过第一次加密得到的字符串 r2 =&quot;+wXp+xOQlFvB+SWknSnAW1lBnwlxaT@@&quot; #第一次加密得到的正确字符串 # a1 = [102, 108, 97, 103, 123, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 125] a1 = [32]*22 # #输入值转成十进制，32是有效字符的开始 while 1: j = 0 #v8 for i in range(0,22,3): #i i2 = i if i2 &gt;= 22: break x = (a1[i]&gt;&gt;2) &amp; 63 #右移两位然后与63（0x3f） r1[j] = s[x] ############################## if r1[j]!=r2[j]: #如果对不上就会加一，从32往上加，直到相等 a1[i] += 1 if a1[i]&gt;126: a1[i-1]+=1 break ############################# j += 1 x=(a1[i]&lt;&lt;4) &amp; 48 #左移四位然后与48（0x30） i2 = i + 1 if i2 &gt;= 22: #最后三位 r1[j]=s[x] j += 1 r1[j] = &apos;@&apos; j += 1 r1[j] = &apos;@&apos; j += 1 break y = ((a1[i+1]&gt;&gt;4) &amp; 15) | x #右移4位与15 然后或运算 前面计算出来的X r1[j] = s[y] ############################## if r1[j]!=r2[j]: #爆破用 a1[i+1] += 1 if a1[i+1]&gt;126: a1[i]+=1 a1[i+1]=32 break ############################# j += 1 x = (a1[i+1]&lt;&lt;2) &amp; 60 #左移2位与60 i2 = i + 2 if i2 &gt;= 22: #后两位 r1[j]=s[x] j += 1 r1[j] = &apos;@&apos; j += 1 break n = a1[i+2] y = ((n&gt;&gt;6) &amp; 3) | x #右移6位与3再和上面运算出来的x做或运算 r1[j] = s[y] ############################## if r1[j]!=r2[j]: #爆破 a1[i+2] += 1 if a1[i+2]&gt;126: a1[i+1]+=1 a1[i+2]=32 break ############################# j += 1 x = n &amp; 63 #与63 r1[j] = s[x] ############################## if r1[j]!=r2[j]: #爆破 a1[i+3] += 1 if a1[i+3]&gt;126: a1[i+2]+=1 a1[i+3]=32 break ############################# j +=1 if j==32: break b = [&apos;&apos;]*100 #10进制转为字符串 for i in range(22): b[i] = chr(a1[i]) print &quot;&quot;.join(b) #a1 = &quot;flag{5c28ecb1c26682f7}&quot; #最终flag","path":"2018/10/23/瓯网杯easyeasy/"},{"title":"easy_crackme","text":"界面很简单，随意输入弹出对话框Incorrect Password 有一个congratulation这就是正确提示我们分别ctrl+X查看跳转 有4个跳转跳到错误代码中 只有一个跳入正确代码段中 打开OD调试 找到00401135（Ida中得到）设置断点运行，任意输入，我是123456789123456789成功段在断点出 我们向上找到跳转指令 发现有一个GetDlgItemTextA判断用来获取我们刚刚输入的12345678912345789 下面进行分析 004010A3 |. 50 push eax ; |Buffer = BD85E565 004010A4 |. 68 E8030000 push 0x3E8 ; |ControlID = 3E8 (1000.) 004010A9 |. 57 push edi ; |hWnd = 00401188 004010AA |. FF15 9C504000 call dword ptr ds:[&lt;&amp;USER32.GetDlgItemTe&gt;; \\GetDlgItemTextA 004010B0 |. 807C24 05 61 cmp byte ptr ss:[esp+0x5],0x61 ; 第二个字符同a比较 004010B5 75 7E jnz short Easy_Cra.00401135 ; 不相等则跳转 004010B7 |. 6A 02 push 0x2 004010B9 |. 8D4C24 0A lea ecx,dword ptr ss:[esp+0xA] ; 3456789123456789 004010BD |. 68 78604000 push Easy_Cra.00406078 ; 5y 004010C2 |. 51 push ecx ; Easy_Cra.&lt;ModuleEntryPoint&gt; 004010C3 |. E8 88000000 call Easy_Cra.00401150 ; 23个字符和5y对比 004010C8 |. 83C4 0C add esp,0xC 004010CB |. 85C0 test eax,eax 004010CD 75 66 jnz short Easy_Cra.00401135 004010CF |. 53 push ebx 004010D0 |. 56 push esi ; Easy_Cra.&lt;ModuleEntryPoint&gt; 004010D1 |. BE 6C604000 mov esi,Easy_Cra.0040606C ; R3versing 004010D6 |. 8D4424 10 lea eax,dword ptr ss:[esp+0x10] ; 56789123456789 004010DA |&gt; 8A10 /mov dl,byte ptr ds:[eax] ; 5 7 9 2 4 004010DC |. 8A1E |mov bl,byte ptr ds:[esi] ; R v r i g 004010DE |. 8ACA |mov cl,dl 004010E0 |. 3AD3 |cmp dl,bl ; R和5对比 v和7对比 r,9 i,2 g,4 004010E2 75 1E jnz short Easy_Cra.00401102 004010E4 |. 84C9 |test cl,cl 004010E6 |. 74 16 |je short Easy_Cra.004010FE 004010E8 |. 8A50 01 |mov dl,byte ptr ds:[eax+0x1] ; 6 8 1 3 004010EB |. 8A5E 01 |mov bl,byte ptr ds:[esi+0x1] ; 3 e s n 004010EE |. 8ACA |mov cl,dl 004010F0 |. 3AD3 |cmp dl,bl ; 3和6对比 e,8 s,1 n,3 004010F2 75 0E jnz short Easy_Cra.00401102 004010F4 |. 83C0 02 |add eax,0x2 004010F7 |. 83C6 02 |add esi,0x2 004010FA |. 84C9 |test cl,cl 004010FC |.^ 75 DC \\jnz short Easy_Cra.004010DA ; 循环 004010FE |&gt; 33C0 xor eax,eax 00401100 |. EB 05 jmp short Easy_Cra.00401107 00401102 |&gt; 1BC0 sbb eax,eax 00401104 |. 83D8 FF sbb eax,-0x1 00401107 |&gt; 5E pop esi ; kernel32.76D662C4 00401108 |. 5B pop ebx ; kernel32.76D662C4 00401109 |. 85C0 test eax,eax 0040110B 75 28 jnz short Easy_Cra.00401135 0040110D |. 807C24 04 45 cmp byte ptr ss:[esp+0x4],0x45 ; 1和0x45=E比较 00401112 75 21 jnz short Easy_Cra.00401135 ; 不同则跳转 00401114 |. 6A 40 push 0x40 ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL 00401116 |. 68 58604000 push Easy_Cra.00406058 ; |EasyCrackMe 0040111B |. 68 44604000 push Easy_Cra.00406044 ; |Congratulation !! 00401120 |. 57 push edi ; |hOwner = 00401188 00401121 |. FF15 A0504000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \\MessageBoxA 00401127 |. 6A 00 push 0x0 ; /Result = 0x0 00401129 |. 57 push edi ; |hWnd = 00401188 0040112A |. FF15 A4504000 call dword ptr ds:[&lt;&amp;USER32.EndDialog&gt;] ; \\EndDialog 00401130 |. 5F pop edi ; kernel32.76D662C4 00401131 |. 83C4 64 add esp,0x64 00401134 |. C3 retn 00401135 |&gt; 6A 10 push 0x10 ; /Style = MB_OK|MB_ICONHAND|MB_APPLMODAL 00401137 |. 68 58604000 push Easy_Cra.00406058 ; |EasyCrackMe 0040113C |. 68 30604000 push Easy_Cra.00406030 ; |Incorrect Password 00401141 |. 57 push edi ; |hOwner = 00401188 00401142 |. FF15 A0504000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \\MessageBoxA 分析过程中我是吧jnz改为jz是的跳转不能实现，方便我们跟踪调试 最终的password是Ea5yR3versing","path":"2018/10/14/easy-crackme/"},{"title":"160个crackme之001","text":"1.程序分析 想要破解一个程序首先就要先了解这个程序（先做一个备份），打开里面有三个按钮，从左到右分别是用户名/注册码、退出、注册码。先进入第一个随意输入用户名/序列号，然后check it baby！，弹出提示对话框Sorry， The Serial is incorrect !，记住这个提示，第三个就是直接输入注册码一类的东西。 知道提示后，就比较好办，我们只要找到弹出对话框的地方，然后向上寻找关键跳转，jmp或者nop掉就可以了。 2.具体步骤 我们使用OD打开,F12暂停法，先运行程序，输入用户名和伪码（我输的是112233/123123123），然后点Check it baby！，弹出对话框先不急着关闭，F12暂停，然后点击工具栏中的K，进入堆栈页面上面有连个MessageBox的地址第一个7778D118显然太大，那就只有第二个了，然后下面的一个函数调用也可以先注意一下。右键第二个MessageBox，显示调用，给这个call断点，然后向上找到函数的头部（push ebp），下断点 0042A170 /$ 55 push ebp 0042A171 |. 8BEC mov ebp,esp 0042A173 |. 83C4 F4 add esp,-0xC 0042A176 |. 53 push ebx 0042A177 |. 56 push esi 0042A178 |. 57 push edi 0042A179 |. 8BF9 mov edi,ecx 0042A17B |. 8BF2 mov esi,edx 0042A17D |. 8BD8 mov ebx,eax 0042A17F |. E8 7CB4FDFF call &lt;jmp.&amp;user32.GetActiveWindow&gt; ; [GetActiveWindow 0042A184 |. 8945 F8 mov [local.2],eax 0042A187 |. 33C0 xor eax,eax 0042A189 |. E8 12A0FFFF call Acid_bur.004241A0 0042A18E |. 8945 F4 mov [local.3],eax 0042A191 |. 33C0 xor eax,eax 0042A193 |. 55 push ebp 0042A194 |. 68 D0A14200 push Acid_bur.0042A1D0 0042A199 |. 64:FF30 push dword ptr fs:[eax] 0042A19C |. 64:8920 mov dword ptr fs:[eax],esp 0042A19F |. 8B45 08 mov eax,[arg.1] 0042A1A2 |. 50 push eax ; /Style = MB_OKCANCEL|MB_APPLMODAL 0042A1A3 |. 57 push edi ; |Title = 00C0058E ??? 0042A1A4 |. 56 push esi ; |Text = NULL 0042A1A5 |. 8B43 24 mov eax,dword ptr ds:[ebx+0x24] ; | 0042A1A8 |. 50 push eax ; |hOwner = 00000001 0042A1A9 |. E8 FAB5FDFF call &lt;jmp.&amp;user32.MessageBoxA&gt; ; \\MessageBoxA 重新点击Check it baby！程序段在push ebp处，观察堆栈处有一个 0019F804 0042FB37 返回到 Acid_bur.0042FB37 来自 Acid_bur.0042A170 右键反汇编窗口中跟随 0042FAF8 |. 8B55 F0 mov edx,[local.4] 0042FAFB |. 8B45 F4 mov eax,[local.3] 0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC 0042FB03 75 1A jnz short Acid_bur.0042FB1F 0042FB05 |. 6A 00 push 0x0 0042FB07 |. B9 CCFB4200 mov ecx,Acid_bur.0042FBCC ; Congratz !! 0042FB0C |. BA D8FB4200 mov edx,Acid_bur.0042FBD8 ; Good job dude =) 0042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB16 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.00424090 0042FB18 |. E8 53A6FFFF call Acid_bur.0042A170 0042FB1D |. EB 18 jmp short Acid_bur.0042FB37 0042FB1F |&gt; 6A 00 push 0x0 0042FB21 |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again! 0042FB26 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect ! 0042FB2B |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB30 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.00424090 0042FB32 |. E8 39A6FFFF call Acid_bur.0042A170 0042FB37 |&gt; 33C0 xor eax,eax 发现有两跳转，一个是jnz他跳转的地址是0042FB1F就是说条件成立就准备弹出Try Again!和Sorry , The serial is incorect !，另一个是jmp，他会跳出错误提示，所以判断jnz为关键跳转我们将它nop掉然后再次点击Check it baby!提示Good Job！爆破成功！ 3.注册机部分以上是爆破分析，下面我们看能不能分析出算法。我们在jnz上面的3个call上面下断点跟踪查看过程0042FAE5 出现40180042FAF3 发现堆栈处出现类似于注册码的0019F82C 020F9A3C ASCII “CW-4018-CRACKED”然后我们尝试一下，另开一个软件输入用户名112233注册码CW-4018-CRACKED，发现是正确的0042FAFE 我们观察寄存器 EAX 020F9A3C ASCII &quot;CW-4018-CRACKED&quot; ECX 8C6945B4 EDX 020F9A58 ASCII &quot;123123123&quot; EBX 020F6EEC ASCII &quot;x鸟&quot; ESP 0019F80C EBP 0019F838 ESI 00000506 EDI 020F9B3C EIP 0042FAFE Acid_bur.0042FAFE 判断这个call作用是与我刚刚输入的123123123做对比，然后决定是否跳转 上面的三个call中的数据我们判断算法可能在上面，我们在0042FA82出下断点单步跟踪查看 0042FA82 |. E8 D1AFFEFF call Acid_bur.0041AA58 0042FA87 |. 8B45 F0 mov eax,[local.4] ; eax=112233 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; 取了第一个字节1=0x31 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; 与0x29相乘 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax ; 0x31*0x29=0x7D9=eax 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; 0x7D9+0x7D9=0xBF2 就是乘二 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,Acid_bur.0042FBAC ; CW 0042FAAB |. E8 583CFDFF call Acid_bur.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,Acid_bur.0042FBB8 ; CRACKED 0042FAB8 |. E8 4B3CFDFF call Acid_bur.00403708 0042FABD |. FF75 FC push [local.1] ; Acid_bur.0042FBAC 0042FAC0 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; - 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FACD |. E8 466CFDFF call Acid_bur.00406718 0042FAD2 |. FF75 E8 push [local.6] ; FB2转化为十进制，就是中间的值4018 0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; - 0042FADA |. FF75 F8 push [local.2] ; Acid_bur.0042FBB8 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA58 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; EDX=123123123之前我输入的注册码 0042FAFB |. 8B45 F4 mov eax,[local.3] ; EAX=CW-4018-CRACKED 0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC ; 判断注册码是否正确 0042FB03 75 1A jnz short Acid_bur.0042FB1F 我们看到中间的数的算法就是取用户名第一个字符然后转为16进制ascii码，然后乘0x29，最后的结果再乘2，最后转化为十进制，然后头尾的CW-和-CRACKED是固定的。 然后就是剩下的serial按钮，我们还是用刚才同样的方法调试前面的步骤一样，到堆栈窗口，从返汇编窗口中跟随开始下面是我们跟踪到的界面 0042F484 |. 64:FF30 push dword ptr fs:[eax] 0042F487 |. 64:8920 mov dword ptr fs:[eax],esp 0042F48A |. 8D45 FC lea eax,[local.1] 0042F48D |. BA 40F54200 mov edx,Acid_bur.0042F540 ; Hello 0042F492 |. E8 7142FDFF call Acid_bur.00403708 0042F497 |. 8D45 F8 lea eax,[local.2] 0042F49A |. BA 50F54200 mov edx,Acid_bur.0042F550 ; Dude! 0042F49F |. E8 6442FDFF call Acid_bur.00403708 0042F4A4 |. FF75 FC push [local.1] ; Acid_bur.0042F540 0042F4A7 |. 68 60F54200 push Acid_bur.0042F560 0042F4AC |. FF75 F8 push [local.2] ; Acid_bur.0042F550 0042F4AF |. 8D45 F4 lea eax,[local.3] 0042F4B2 |. BA 03000000 mov edx,0x3 0042F4B7 |. E8 F044FDFF call Acid_bur.004039AC 0042F4BC |. 8D55 F0 lea edx,[local.4] 0042F4BF |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042F4C5 |. E8 8EB5FEFF call Acid_bur.0041AA58 0042F4CA |. 8B45 F0 mov eax,[local.4] 0042F4CD |. 8B55 F4 mov edx,[local.3] 0042F4D0 |. E8 2745FDFF call Acid_bur.004039FC 0042F4D5 |. 75 1A jnz short Acid_bur.0042F4F1 0042F4D7 |. 6A 00 push 0x0 0042F4D9 |. B9 64F54200 mov ecx,Acid_bur.0042F564 ; Congratz! 0042F4DE |. BA 70F54200 mov edx,Acid_bur.0042F570 ; God Job dude !! =) 0042F4E3 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042F4E8 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.00424090 0042F4EA |. E8 81ACFFFF call Acid_bur.0042A170 0042F4EF |. EB 18 jmp short Acid_bur.0042F509 0042F4F1 |&gt; 6A 00 push 0x0 0042F4F3 |. B9 84F54200 mov ecx,Acid_bur.0042F584 ; Failed! 0042F4F8 |. BA 8CF54200 mov edx,Acid_bur.0042F58C ; Try Again!! 0042F4FD |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042F502 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.00424090 0042F504 |. E8 67ACFFFF call Acid_bur.0042A170 0042F509 |&gt; 33C0 xor eax,eax 我们发现jnz跳过了正确的提示，判断为关键跳转，那么注册码的验证应该在上面我们再上面的call下断点查看 发现一个Hello Dude!，我们天入验证一下是不是注册码，发现是注册的查看寄存器中EAX=123123123 EDX=”Hello Dude!”判断这个call是EAX和EDX做对比的作用，然后决定是否跳转向上调试发现注册码是一个固定的：Hello Dude!","path":"2018/10/07/160个crackme之001/"},{"title":"实验吧逆向破解课程学习笔记","text":"逆向破解的方法常用软件查壳软件PEID 脱壳软件lordPE、REC 逆向破解软件OD dede 查找按钮事件（地址） 1.暴力破解掌握利用字符串的方法破解程序 原理 利用登录时提供的关键字，找到关键跳转然后将关键跳转命令NOP掉。 方法 先黑盒测试 找到关键字，比如登录框中提供的错误提示 利用右键-&gt;中文搜索引擎-&gt;智能搜索 搜索到关键字false 然后双击关键字，跳转到汇编窗口false对应的哪一行 向上查找关键跳转（就是能够跳转到false语句）（je、jmp、jnz、je） 我们可以通过下断点测试 运行 输入账号密码 查看是否会实现跳转 右键二进制-&gt;用nop填充 复制到可执行文件-选择 保存到文件即可 2.获得注册码原理 利用登录时提供的关键字，找到关键字的call、下断点，单步试调追出注册码 方法 先黑盒测试 找到关键字，比如登录框中提供的错误提示 利用右键-&gt;中文搜索引擎-&gt;智能搜索 搜索到关键字 通过下断点，单步试调找到对应的用户名密码 3.跳转破解jmp：无条件跳转 利用软件登录时提供的关键字，找到关键跳转下断点 更改跳转命令，改变程序流程 空格键：编辑汇编指令 4.带壳破解加壳程序在载入OD时，现在入壳程序，然后有壳程序解密软件。 所以需要跳转到软件解密的地方搜索关键字符串，加密状态下是无法搜索到的 步骤：首先OD载入加壳软件 然后F9运行，使软件运行起来 然后ctrl+g，输入00401000（使软件跳转到程序解密的开始处，这样就可以搜索关键字了） 中文搜索引擎-&gt;智能搜索 之后的步骤就和常规的一样了 5.软件文件大小自校验利用ESP定律脱壳，然后OD把软件文件大小自校验NOP掉，软件正常运行 脱壳完成后还是无法打开软件，判断是软件大小自校验，脱壳后的文件会变大 接下来去除软件大小自校验 插件-&gt;APld断点设置工具0-&gt;常用断点设置-&gt;文件处理-&gt;GetFileSize F9运行到断点出 单击堆栈窗口-&gt;右键-&gt;在反汇编窗口中跟随 F2下断点 端机工具栏中的B，切换到断点窗口，删除getfilesize的断点 getfilesize函数获取了脱壳后的程序大小，然后利用cmp eax,0xc6c8 命令比较 我们把这条指令nop掉即可 6.修改关键call返回值利用软件登录时提供的关键字，找到关键call，改变关键call返回值，进而改变关键跳的流程 通过智能搜索字符串注册 双击定位到反汇编处，向上寻找关键跳转指令，发现吧je指令可以跳过注册，然后找到关键call，修改关键call，使得跳转实现 7.重启验证读取文件利用系统API函数下断点，解压软件，然后跳转到0401000处，查找关键字符串，找到关键跳转下断点，更改跳转命令，改变程序流程 8.万能断点万能断点就是把能下的断点都下一遍 利用万能断点追出注册码 万能断点：F3 A5 8B C8 83 E1 03 F3 A4 E8 单步步过追出注册码 9.VB弹出窗口掌握利用VB弹出函数追出软件内的注册码 在rtcMsgBox函数处下断点，然后追出账号和密码 运行程序输入错误的账号密码，然后单步步过找到关键跳转 10.删除弹窗掌握删除弹窗提示对话框的方法 f12暂停法直接到user32里了，K按钮进入堆栈页面 找到user32.MessageBoxExA，然后下断点 11.真码保存在系统文件运行程序找到关键字 通过关键字找到关键跳转，然后nop掉就可以了 12.BC++手动查找IATBC+被脱壳后需要手工修复ITA 使用ESP定律脱壳 OEP处手动寻找IAT，在jmp下的第一个call，按回车进入call寻找IAT 向上找到段首，右键》数据窗口中跟随》内存地址 然后早内存窗口中，右键长型》地址 0056E114 点击工具栏中的M切换到内存页面软件的基地址为00400000 计算出IAT地址为0016E114 在REC中修改OEP：14E0 RVA：16E114 保存报表 删除无效的指针 修正转储 13.利用dede查找按钮事件软件载入到dede中 单击过程，发现有三个按钮界面 选择按钮事件的段首分别为004046F0和0040479C 把软件载入到od，ctrl+g，给两处下断点 第一个断点没有到输入注册码的地方，删除断点继续运行 然后出入注册码，点击注册 向下寻找关键跳转然后nop掉就可以了 14.ALT+F9关键call追注册码掌握急用ALT+F9的方法找到MessageBox提示框，跳到用户空间，追寻正确的注册码 运行软件，当弹出注册失败框时，返回到OD界面，F12暂停 OD打开运行软件，点击注册输入注册码，出现失败弹窗 返回OD，F12暂停,然后菜单栏中，调试》按钮》执行到用户代码 然后单击确定，返回到用户代码处 15.加壳软件打补丁利用OD追出注册码 智能搜索已注册和未注册 点击已注册跳转到反汇编窗口 向上查找，发现有两个jmp跳过注册成功的提示 在向上寻找能跳过两个jmp的跳转，这就是关键跳转 打开注册机其他》标签》制作内存补丁 选择软件，然后添加修改地址为关键跳转的地址，长度为6，原始指令0F8489040000，修改地址为909090909090 16. 易语言窗体法利用二进制字符串FF 25查找易语言窗体 更改易语言主窗口弹出代码，使程序跳过注册窗口，直接弹出用户界面 17.易语言退出暗桩利用push窗体破解软件时，会遇到暗桩，删除暗桩，正常运行 用OD打开 设置API断点》进程函数》ExitProcess F9运行到断点处，上方有一个调用退出函数的call 再上面有一个可以跳过call 的跳转，把他改成jmp然后保存即可 18.VB按钮脚本破解掌握利用VB脚本下断点，找到关键关键跳转 利用脚本程序下断点，在断点出找到cmp*0xFFFF处，这个cmp比较命令下面的跳转为关键跳转 运行脚本（VB事件断点查找脚本） 然后运行程序，停在断点出 F8单步步过，向下查找有FFFF的命令，紧跟着的跳转就是关键跳转，设置断点，并删除其他断点 把刚才的跳转nop掉，然后Ctrl+g和上方ffff一样的命令，把下面的断点也nop掉 19. 修改软件标题图标PE Explorer修改软件标题信息 用PE Explorer打开软件，单击左侧的rc资源-&gt;TFRMTSFILTER 双击FrmTSFilter:TFrmTSFilter 单击caption然后再下面修改，然后单击应用即可","path":"2018/10/06/实验吧笔记/"},{"title":"Bugku逆向部分writeup","text":"##Easy_vb 用ida打开浏览一下就可以看到flag .text:004023A5 loc_4023A5: ; CODE XREF: .text:00402391↑j .text:004023A5 mov eax, [ebp-18h] .text:004023A8 push eax .text:004023A9 push offset aMctfN3tRev1sE4 ; &quot;MCTF{_N3t_Rev_1s_E4ay_}&quot; .text:004023AE call ds:__vbaStrCmp .text:004023B4 mov edi, eax .text:004023B6 lea ecx, [ebp-18h] .text:004023B9 neg edi .text:004023BB sbb edi, edi .text:004023BD inc edi .text:004023BE neg edi ##Easy_Re用OD打开右键》智能搜索》中文引擎搜索发现flag就在上面 ##入门逆向 ida打开搜索关键字this is a babyre下面就是flag flag{Re_1s_S0_C0OL}","path":"2018/10/03/bugkuwriteup/"},{"title":"WannaLOL2解题(详细)","text":"WannaLOL2解题1.黑盒测试运行文件，看看有什么效果&lt;br/&gt; 黑盒测试 输入，限制长度，控制，提示错误之类的&lt;br/&gt; 判断位数，32位/64位&lt;br/&gt; 可以通过IDA打开看看，64位只能打开64位的文件，32位只能打开32位的文件&lt;br/&gt; IDA7.0他会提示错误如果打开错误&lt;br/&gt; 这一栏也有提示，这个文件是32位的&lt;br/&gt; 2.分析程序搜索关键字符串error&lt;br/&gt; 判断语句在上方&lt;br/&gt; push为函数的开始，return为函数的结束&lt;br/&gt; --------- 代表函数的开始 因为不是很会汇编所以我利用IDA的F5功能把他编译成C语言&lt;br/&gt; 编译之前发现有两段花指令 花指令是程序中的无用代码，程序多它没影响，少了它也能正常运行。加花指令后，杀毒软件对木马静态反汇编时，木马的代码就不会正常显示出来，加大杀毒软件的查杀难度。&lt;br/&gt; 绕过花指令有两种方法&lt;br/&gt; 首先我们要设置Number of opcode bytes（操作码的字节数），我使用的是8 修改完之后就会出现以下情况&lt;br/&gt; 其中话指令说对应的就是E8 ，扰乱了反编译的过程 有两种绕过方式，分别在两条花指令中操作一、首先我们选中E8绕后打开Hex View 这样就可以定位到对应的地方&lt;br/&gt; F2 将他改成90 然后F2确认 我们发现E8改为90&lt;br/&gt; 后面的数据变正常了 90：是一个单独的指令，是一个什么都不做的指令 二、第二种方法我们选中E8的位置按u（undfine） 然后选择下面的66按c（code） 变成如下情况&lt;br/&gt; 就好像E8被注释掉了 花指令已经被我们绕过 我们选中整个函数从push开始到retn&lt;br/&gt; 按p&lt;br/&gt; 然后按F5 这是编译后的伪C 这一段应该简单的&lt;br/&gt; 上面是ascii码&lt;br/&gt; 我们把它转换回来 根据这个我们可以判断出来长度是4，第一位是1，第二位是5 后面两位我们继续往下看 我把四个字符串改为c1，c2，c3，c4 v10 = C3 - &apos;0&apos;; v0 = (double)v10; v10 = C1 - &apos;0&apos;; v1 = (double)v10; v10 = C2 - &apos;0&apos;; v2 = v1 / (double)v10; v10 = C4 - &apos;0&apos;; *(float *)&amp;v10 = (v0 - v2) * (double)v10 * 16.0; if ( *(float *)&amp;v10 != 384.0 ) 我这里列出了关键部分，其他语句没有什么意义的已知C1=1，C2=5 (c3-1/5)*c4*16.0=384.0 (c3-0.2)*c4==24.0 然后我们可以简单的穷举","path":"2018/07/12/WannaLOL2解题/"}]}