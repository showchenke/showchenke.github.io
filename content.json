{"pages":[],"posts":[{"title":"easy_crackme","text":"界面很简单，随意输入弹出对话框Incorrect Password 有一个congratulation这就是正确提示我们分别ctrl+X查看跳转 有4个跳转跳到错误代码中 只有一个跳入正确代码段中 打开OD调试 找到00401135（Ida中得到）设置断点运行，任意输入，我是123456789123456789成功段在断点出 我们向上找到跳转指令 发现有一个GetDlgItemTextA判断用来获取我们刚刚输入的12345678912345789 下面进行分析 004010A3 |. 50 push eax ; |Buffer = BD85E565 004010A4 |. 68 E8030000 push 0x3E8 ; |ControlID = 3E8 (1000.) 004010A9 |. 57 push edi ; |hWnd = 00401188 004010AA |. FF15 9C504000 call dword ptr ds:[&lt;&amp;USER32.GetDlgItemTe&gt;; \\GetDlgItemTextA 004010B0 |. 807C24 05 61 cmp byte ptr ss:[esp+0x5],0x61 ; 第二个字符同a比较 004010B5 75 7E jnz short Easy_Cra.00401135 ; 不相等则跳转 004010B7 |. 6A 02 push 0x2 004010B9 |. 8D4C24 0A lea ecx,dword ptr ss:[esp+0xA] ; 3456789123456789 004010BD |. 68 78604000 push Easy_Cra.00406078 ; 5y 004010C2 |. 51 push ecx ; Easy_Cra.&lt;ModuleEntryPoint&gt; 004010C3 |. E8 88000000 call Easy_Cra.00401150 ; 23个字符和5y对比 004010C8 |. 83C4 0C add esp,0xC 004010CB |. 85C0 test eax,eax 004010CD 75 66 jnz short Easy_Cra.00401135 004010CF |. 53 push ebx 004010D0 |. 56 push esi ; Easy_Cra.&lt;ModuleEntryPoint&gt; 004010D1 |. BE 6C604000 mov esi,Easy_Cra.0040606C ; R3versing 004010D6 |. 8D4424 10 lea eax,dword ptr ss:[esp+0x10] ; 56789123456789 004010DA |&gt; 8A10 /mov dl,byte ptr ds:[eax] ; 5 7 9 2 4 004010DC |. 8A1E |mov bl,byte ptr ds:[esi] ; R v r i g 004010DE |. 8ACA |mov cl,dl 004010E0 |. 3AD3 |cmp dl,bl ; R和5对比 v和7对比 r,9 i,2 g,4 004010E2 75 1E jnz short Easy_Cra.00401102 004010E4 |. 84C9 |test cl,cl 004010E6 |. 74 16 |je short Easy_Cra.004010FE 004010E8 |. 8A50 01 |mov dl,byte ptr ds:[eax+0x1] ; 6 8 1 3 004010EB |. 8A5E 01 |mov bl,byte ptr ds:[esi+0x1] ; 3 e s n 004010EE |. 8ACA |mov cl,dl 004010F0 |. 3AD3 |cmp dl,bl ; 3和6对比 e,8 s,1 n,3 004010F2 75 0E jnz short Easy_Cra.00401102 004010F4 |. 83C0 02 |add eax,0x2 004010F7 |. 83C6 02 |add esi,0x2 004010FA |. 84C9 |test cl,cl 004010FC |.^ 75 DC \\jnz short Easy_Cra.004010DA ; 循环 004010FE |&gt; 33C0 xor eax,eax 00401100 |. EB 05 jmp short Easy_Cra.00401107 00401102 |&gt; 1BC0 sbb eax,eax 00401104 |. 83D8 FF sbb eax,-0x1 00401107 |&gt; 5E pop esi ; kernel32.76D662C4 00401108 |. 5B pop ebx ; kernel32.76D662C4 00401109 |. 85C0 test eax,eax 0040110B 75 28 jnz short Easy_Cra.00401135 0040110D |. 807C24 04 45 cmp byte ptr ss:[esp+0x4],0x45 ; 1和0x45=E比较 00401112 75 21 jnz short Easy_Cra.00401135 ; 不同则跳转 00401114 |. 6A 40 push 0x40 ; /Style = MB_OK|MB_ICONASTERISK|MB_APPLMODAL 00401116 |. 68 58604000 push Easy_Cra.00406058 ; |EasyCrackMe 0040111B |. 68 44604000 push Easy_Cra.00406044 ; |Congratulation !! 00401120 |. 57 push edi ; |hOwner = 00401188 00401121 |. FF15 A0504000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \\MessageBoxA 00401127 |. 6A 00 push 0x0 ; /Result = 0x0 00401129 |. 57 push edi ; |hWnd = 00401188 0040112A |. FF15 A4504000 call dword ptr ds:[&lt;&amp;USER32.EndDialog&gt;] ; \\EndDialog 00401130 |. 5F pop edi ; kernel32.76D662C4 00401131 |. 83C4 64 add esp,0x64 00401134 |. C3 retn 00401135 |&gt; 6A 10 push 0x10 ; /Style = MB_OK|MB_ICONHAND|MB_APPLMODAL 00401137 |. 68 58604000 push Easy_Cra.00406058 ; |EasyCrackMe 0040113C |. 68 30604000 push Easy_Cra.00406030 ; |Incorrect Password 00401141 |. 57 push edi ; |hOwner = 00401188 00401142 |. FF15 A0504000 call dword ptr ds:[&lt;&amp;USER32.MessageBoxA&gt;&gt;; \\MessageBoxA 分析过程中我是吧jnz改为jz是的跳转不能实现，方便我们跟踪调试 最终的password是Ea5yR3versing","path":"2018/10/14/easy-crackme/"},{"title":"160个crackme之001","text":"1.程序分析 想要破解一个程序首先就要先了解这个程序（先做一个备份），打开里面有三个按钮，从左到右分别是用户名/注册码、退出、注册码。先进入第一个随意输入用户名/序列号，然后check it baby！，弹出提示对话框Sorry， The Serial is incorrect !，记住这个提示，第三个就是直接输入注册码一类的东西。 知道提示后，就比较好办，我们只要找到弹出对话框的地方，然后向上寻找关键跳转，jmp或者nop掉就可以了。 2.具体步骤 我们使用OD打开,F12暂停法，先运行程序，输入用户名和伪码（我输的是112233/123123123），然后点Check it baby！，弹出对话框先不急着关闭，F12暂停，然后点击工具栏中的K，进入堆栈页面上面有连个MessageBox的地址第一个7778D118显然太大，那就只有第二个了，然后下面的一个函数调用也可以先注意一下。右键第二个MessageBox，显示调用，给这个call断点，然后向上找到函数的头部（push ebp），下断点 0042A170 /$ 55 push ebp 0042A171 |. 8BEC mov ebp,esp 0042A173 |. 83C4 F4 add esp,-0xC 0042A176 |. 53 push ebx 0042A177 |. 56 push esi 0042A178 |. 57 push edi 0042A179 |. 8BF9 mov edi,ecx 0042A17B |. 8BF2 mov esi,edx 0042A17D |. 8BD8 mov ebx,eax 0042A17F |. E8 7CB4FDFF call &lt;jmp.&amp;user32.GetActiveWindow&gt; ; [GetActiveWindow 0042A184 |. 8945 F8 mov [local.2],eax 0042A187 |. 33C0 xor eax,eax 0042A189 |. E8 12A0FFFF call Acid_bur.004241A0 0042A18E |. 8945 F4 mov [local.3],eax 0042A191 |. 33C0 xor eax,eax 0042A193 |. 55 push ebp 0042A194 |. 68 D0A14200 push Acid_bur.0042A1D0 0042A199 |. 64:FF30 push dword ptr fs:[eax] 0042A19C |. 64:8920 mov dword ptr fs:[eax],esp 0042A19F |. 8B45 08 mov eax,[arg.1] 0042A1A2 |. 50 push eax ; /Style = MB_OKCANCEL|MB_APPLMODAL 0042A1A3 |. 57 push edi ; |Title = 00C0058E ??? 0042A1A4 |. 56 push esi ; |Text = NULL 0042A1A5 |. 8B43 24 mov eax,dword ptr ds:[ebx+0x24] ; | 0042A1A8 |. 50 push eax ; |hOwner = 00000001 0042A1A9 |. E8 FAB5FDFF call &lt;jmp.&amp;user32.MessageBoxA&gt; ; \\MessageBoxA 重新点击Check it baby！程序段在push ebp处，观察堆栈处有一个 0019F804 0042FB37 返回到 Acid_bur.0042FB37 来自 Acid_bur.0042A170 右键反汇编窗口中跟随 0042FAF8 |. 8B55 F0 mov edx,[local.4] 0042FAFB |. 8B45 F4 mov eax,[local.3] 0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC 0042FB03 75 1A jnz short Acid_bur.0042FB1F 0042FB05 |. 6A 00 push 0x0 0042FB07 |. B9 CCFB4200 mov ecx,Acid_bur.0042FBCC ; Congratz !! 0042FB0C |. BA D8FB4200 mov edx,Acid_bur.0042FBD8 ; Good job dude =) 0042FB11 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB16 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.00424090 0042FB18 |. E8 53A6FFFF call Acid_bur.0042A170 0042FB1D |. EB 18 jmp short Acid_bur.0042FB37 0042FB1F |&gt; 6A 00 push 0x0 0042FB21 |. B9 74FB4200 mov ecx,Acid_bur.0042FB74 ; Try Again! 0042FB26 |. BA 80FB4200 mov edx,Acid_bur.0042FB80 ; Sorry , The serial is incorect ! 0042FB2B |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042FB30 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.00424090 0042FB32 |. E8 39A6FFFF call Acid_bur.0042A170 0042FB37 |&gt; 33C0 xor eax,eax 发现有两跳转，一个是jnz他跳转的地址是0042FB1F就是说条件成立就准备弹出Try Again!和Sorry , The serial is incorect !，另一个是jmp，他会跳出错误提示，所以判断jnz为关键跳转我们将它nop掉然后再次点击Check it baby!提示Good Job！爆破成功！ 3.注册机部分以上是爆破分析，下面我们看能不能分析出算法。我们在jnz上面的3个call上面下断点跟踪查看过程0042FAE5 出现40180042FAF3 发现堆栈处出现类似于注册码的0019F82C 020F9A3C ASCII “CW-4018-CRACKED”然后我们尝试一下，另开一个软件输入用户名112233注册码CW-4018-CRACKED，发现是正确的0042FAFE 我们观察寄存器 EAX 020F9A3C ASCII &quot;CW-4018-CRACKED&quot; ECX 8C6945B4 EDX 020F9A58 ASCII &quot;123123123&quot; EBX 020F6EEC ASCII &quot;x鸟&quot; ESP 0019F80C EBP 0019F838 ESI 00000506 EDI 020F9B3C EIP 0042FAFE Acid_bur.0042FAFE 判断这个call作用是与我刚刚输入的123123123做对比，然后决定是否跳转 上面的三个call中的数据我们判断算法可能在上面，我们在0042FA82出下断点单步跟踪查看 0042FA82 |. E8 D1AFFEFF call Acid_bur.0041AA58 0042FA87 |. 8B45 F0 mov eax,[local.4] ; eax=112233 0042FA8A |. 0FB600 movzx eax,byte ptr ds:[eax] ; 取了第一个字节1=0x31 0042FA8D |. F72D 50174300 imul dword ptr ds:[0x431750] ; 与0x29相乘 0042FA93 |. A3 50174300 mov dword ptr ds:[0x431750],eax ; 0x31*0x29=0x7D9=eax 0042FA98 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FA9D |. 0105 50174300 add dword ptr ds:[0x431750],eax ; 0x7D9+0x7D9=0xBF2 就是乘二 0042FAA3 |. 8D45 FC lea eax,[local.1] 0042FAA6 |. BA ACFB4200 mov edx,Acid_bur.0042FBAC ; CW 0042FAAB |. E8 583CFDFF call Acid_bur.00403708 0042FAB0 |. 8D45 F8 lea eax,[local.2] 0042FAB3 |. BA B8FB4200 mov edx,Acid_bur.0042FBB8 ; CRACKED 0042FAB8 |. E8 4B3CFDFF call Acid_bur.00403708 0042FABD |. FF75 FC push [local.1] ; Acid_bur.0042FBAC 0042FAC0 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; - 0042FAC5 |. 8D55 E8 lea edx,[local.6] 0042FAC8 |. A1 50174300 mov eax,dword ptr ds:[0x431750] 0042FACD |. E8 466CFDFF call Acid_bur.00406718 0042FAD2 |. FF75 E8 push [local.6] ; FB2转化为十进制，就是中间的值4018 0042FAD5 |. 68 C8FB4200 push Acid_bur.0042FBC8 ; - 0042FADA |. FF75 F8 push [local.2] ; Acid_bur.0042FBB8 0042FADD |. 8D45 F4 lea eax,[local.3] 0042FAE0 |. BA 05000000 mov edx,0x5 0042FAE5 |. E8 C23EFDFF call Acid_bur.004039AC 0042FAEA |. 8D55 F0 lea edx,[local.4] 0042FAED |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042FAF3 |. E8 60AFFEFF call Acid_bur.0041AA58 0042FAF8 |. 8B55 F0 mov edx,[local.4] ; EDX=123123123之前我输入的注册码 0042FAFB |. 8B45 F4 mov eax,[local.3] ; EAX=CW-4018-CRACKED 0042FAFE |. E8 F93EFDFF call Acid_bur.004039FC ; 判断注册码是否正确 0042FB03 75 1A jnz short Acid_bur.0042FB1F 我们看到中间的数的算法就是取用户名第一个字符然后转为16进制ascii码，然后乘0x29，最后的结果再乘2，最后转化为十进制，然后头尾的CW-和-CRACKED是固定的。 然后就是剩下的serial按钮，我们还是用刚才同样的方法调试前面的步骤一样，到堆栈窗口，从返汇编窗口中跟随开始下面是我们跟踪到的界面 0042F484 |. 64:FF30 push dword ptr fs:[eax] 0042F487 |. 64:8920 mov dword ptr fs:[eax],esp 0042F48A |. 8D45 FC lea eax,[local.1] 0042F48D |. BA 40F54200 mov edx,Acid_bur.0042F540 ; Hello 0042F492 |. E8 7142FDFF call Acid_bur.00403708 0042F497 |. 8D45 F8 lea eax,[local.2] 0042F49A |. BA 50F54200 mov edx,Acid_bur.0042F550 ; Dude! 0042F49F |. E8 6442FDFF call Acid_bur.00403708 0042F4A4 |. FF75 FC push [local.1] ; Acid_bur.0042F540 0042F4A7 |. 68 60F54200 push Acid_bur.0042F560 0042F4AC |. FF75 F8 push [local.2] ; Acid_bur.0042F550 0042F4AF |. 8D45 F4 lea eax,[local.3] 0042F4B2 |. BA 03000000 mov edx,0x3 0042F4B7 |. E8 F044FDFF call Acid_bur.004039AC 0042F4BC |. 8D55 F0 lea edx,[local.4] 0042F4BF |. 8B83 E0010000 mov eax,dword ptr ds:[ebx+0x1E0] 0042F4C5 |. E8 8EB5FEFF call Acid_bur.0041AA58 0042F4CA |. 8B45 F0 mov eax,[local.4] 0042F4CD |. 8B55 F4 mov edx,[local.3] 0042F4D0 |. E8 2745FDFF call Acid_bur.004039FC 0042F4D5 |. 75 1A jnz short Acid_bur.0042F4F1 0042F4D7 |. 6A 00 push 0x0 0042F4D9 |. B9 64F54200 mov ecx,Acid_bur.0042F564 ; Congratz! 0042F4DE |. BA 70F54200 mov edx,Acid_bur.0042F570 ; God Job dude !! =) 0042F4E3 |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042F4E8 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.00424090 0042F4EA |. E8 81ACFFFF call Acid_bur.0042A170 0042F4EF |. EB 18 jmp short Acid_bur.0042F509 0042F4F1 |&gt; 6A 00 push 0x0 0042F4F3 |. B9 84F54200 mov ecx,Acid_bur.0042F584 ; Failed! 0042F4F8 |. BA 8CF54200 mov edx,Acid_bur.0042F58C ; Try Again!! 0042F4FD |. A1 480A4300 mov eax,dword ptr ds:[0x430A48] 0042F502 |. 8B00 mov eax,dword ptr ds:[eax] ; Acid_bur.00424090 0042F504 |. E8 67ACFFFF call Acid_bur.0042A170 0042F509 |&gt; 33C0 xor eax,eax 我们发现jnz跳过了正确的提示，判断为关键跳转，那么注册码的验证应该在上面我们再上面的call下断点查看 发现一个Hello Dude!，我们天入验证一下是不是注册码，发现是注册的查看寄存器中EAX=123123123 EDX=”Hello Dude!”判断这个call是EAX和EDX做对比的作用，然后决定是否跳转向上调试发现注册码是一个固定的：Hello Dude!","path":"2018/10/07/160个crackme之001/"},{"title":"实验吧逆向破解课程学习笔记","text":"逆向破解的方法常用软件查壳软件PEID 脱壳软件lordPE、REC 逆向破解软件OD dede 查找按钮事件（地址） 1.暴力破解掌握利用字符串的方法破解程序 原理 利用登录时提供的关键字，找到关键跳转然后将关键跳转命令NOP掉。 方法 先黑盒测试 找到关键字，比如登录框中提供的错误提示 利用右键-&gt;中文搜索引擎-&gt;智能搜索 搜索到关键字false 然后双击关键字，跳转到汇编窗口false对应的哪一行 向上查找关键跳转（就是能够跳转到false语句）（je、jmp、jnz、je） 我们可以通过下断点测试 运行 输入账号密码 查看是否会实现跳转 右键二进制-&gt;用nop填充 复制到可执行文件-选择 保存到文件即可 2.获得注册码原理 利用登录时提供的关键字，找到关键字的call、下断点，单步试调追出注册码 方法 先黑盒测试 找到关键字，比如登录框中提供的错误提示 利用右键-&gt;中文搜索引擎-&gt;智能搜索 搜索到关键字 通过下断点，单步试调找到对应的用户名密码 3.跳转破解jmp：无条件跳转 利用软件登录时提供的关键字，找到关键跳转下断点 更改跳转命令，改变程序流程 空格键：编辑汇编指令 4.带壳破解加壳程序在载入OD时，现在入壳程序，然后有壳程序解密软件。 所以需要跳转到软件解密的地方搜索关键字符串，加密状态下是无法搜索到的 步骤：首先OD载入加壳软件 然后F9运行，使软件运行起来 然后ctrl+g，输入00401000（使软件跳转到程序解密的开始处，这样就可以搜索关键字了） 中文搜索引擎-&gt;智能搜索 之后的步骤就和常规的一样了 5.软件文件大小自校验利用ESP定律脱壳，然后OD把软件文件大小自校验NOP掉，软件正常运行 脱壳完成后还是无法打开软件，判断是软件大小自校验，脱壳后的文件会变大 接下来去除软件大小自校验 插件-&gt;APld断点设置工具0-&gt;常用断点设置-&gt;文件处理-&gt;GetFileSize F9运行到断点出 单击堆栈窗口-&gt;右键-&gt;在反汇编窗口中跟随 F2下断点 端机工具栏中的B，切换到断点窗口，删除getfilesize的断点 getfilesize函数获取了脱壳后的程序大小，然后利用cmp eax,0xc6c8 命令比较 我们把这条指令nop掉即可 6.修改关键call返回值利用软件登录时提供的关键字，找到关键call，改变关键call返回值，进而改变关键跳的流程 通过智能搜索字符串注册 双击定位到反汇编处，向上寻找关键跳转指令，发现吧je指令可以跳过注册，然后找到关键call，修改关键call，使得跳转实现 7.重启验证读取文件利用系统API函数下断点，解压软件，然后跳转到0401000处，查找关键字符串，找到关键跳转下断点，更改跳转命令，改变程序流程 8.万能断点万能断点就是把能下的断点都下一遍 利用万能断点追出注册码 万能断点：F3 A5 8B C8 83 E1 03 F3 A4 E8 单步步过追出注册码 9.VB弹出窗口掌握利用VB弹出函数追出软件内的注册码 在rtcMsgBox函数处下断点，然后追出账号和密码 运行程序输入错误的账号密码，然后单步步过找到关键跳转 10.删除弹窗掌握删除弹窗提示对话框的方法 f12暂停法直接到user32里了，K按钮进入堆栈页面 找到user32.MessageBoxExA，然后下断点 11.真码保存在系统文件运行程序找到关键字 通过关键字找到关键跳转，然后nop掉就可以了 12.BC++手动查找IATBC+被脱壳后需要手工修复ITA 使用ESP定律脱壳 OEP处手动寻找IAT，在jmp下的第一个call，按回车进入call寻找IAT 向上找到段首，右键》数据窗口中跟随》内存地址 然后早内存窗口中，右键长型》地址 0056E114 点击工具栏中的M切换到内存页面软件的基地址为00400000 计算出IAT地址为0016E114 在REC中修改OEP：14E0 RVA：16E114 保存报表 删除无效的指针 修正转储 13.利用dede查找按钮事件软件载入到dede中 单击过程，发现有三个按钮界面 选择按钮事件的段首分别为004046F0和0040479C 把软件载入到od，ctrl+g，给两处下断点 第一个断点没有到输入注册码的地方，删除断点继续运行 然后出入注册码，点击注册 向下寻找关键跳转然后nop掉就可以了 14.ALT+F9关键call追注册码掌握急用ALT+F9的方法找到MessageBox提示框，跳到用户空间，追寻正确的注册码 运行软件，当弹出注册失败框时，返回到OD界面，F12暂停 OD打开运行软件，点击注册输入注册码，出现失败弹窗 返回OD，F12暂停,然后菜单栏中，调试》按钮》执行到用户代码 然后单击确定，返回到用户代码处 15.加壳软件打补丁利用OD追出注册码 智能搜索已注册和未注册 点击已注册跳转到反汇编窗口 向上查找，发现有两个jmp跳过注册成功的提示 在向上寻找能跳过两个jmp的跳转，这就是关键跳转 打开注册机其他》标签》制作内存补丁 选择软件，然后添加修改地址为关键跳转的地址，长度为6，原始指令0F8489040000，修改地址为909090909090 16. 易语言窗体法利用二进制字符串FF 25查找易语言窗体 更改易语言主窗口弹出代码，使程序跳过注册窗口，直接弹出用户界面 17.易语言退出暗桩利用push窗体破解软件时，会遇到暗桩，删除暗桩，正常运行 用OD打开 设置API断点》进程函数》ExitProcess F9运行到断点处，上方有一个调用退出函数的call 再上面有一个可以跳过call 的跳转，把他改成jmp然后保存即可 18.VB按钮脚本破解掌握利用VB脚本下断点，找到关键关键跳转 利用脚本程序下断点，在断点出找到cmp*0xFFFF处，这个cmp比较命令下面的跳转为关键跳转 运行脚本（VB事件断点查找脚本） 然后运行程序，停在断点出 F8单步步过，向下查找有FFFF的命令，紧跟着的跳转就是关键跳转，设置断点，并删除其他断点 把刚才的跳转nop掉，然后Ctrl+g和上方ffff一样的命令，把下面的断点也nop掉 19. 修改软件标题图标PE Explorer修改软件标题信息 用PE Explorer打开软件，单击左侧的rc资源-&gt;TFRMTSFILTER 双击FrmTSFilter:TFrmTSFilter 单击caption然后再下面修改，然后单击应用即可","path":"2018/10/06/实验吧笔记/"},{"title":"Bugku逆向部分writeup","text":"##第一题 用ida打开浏览一下就可以看到flag .text:004023A5 loc_4023A5: ; CODE XREF: .text:00402391↑j .text:004023A5 mov eax, [ebp-18h] .text:004023A8 push eax .text:004023A9 push offset aMctfN3tRev1sE4 ; &quot;MCTF{_N3t_Rev_1s_E4ay_}&quot; .text:004023AE call ds:__vbaStrCmp .text:004023B4 mov edi, eax .text:004023B6 lea ecx, [ebp-18h] .text:004023B9 neg edi .text:004023BB sbb edi, edi .text:004023BD inc edi .text:004023BE neg edi ##第二题用OD打开右键》智能搜索》中文引擎搜索发现flag就在上面","path":"2018/10/03/bugkuwriteup/"},{"title":"WannaLOL2解题(详细)","text":"WannaLOL2解题1.黑盒测试运行文件，看看有什么效果&lt;br/&gt; 黑盒测试 输入，限制长度，控制，提示错误之类的&lt;br/&gt; 判断位数，32位/64位&lt;br/&gt; 可以通过IDA打开看看，64位只能打开64位的文件，32位只能打开32位的文件&lt;br/&gt; IDA7.0他会提示错误如果打开错误&lt;br/&gt; 这一栏也有提示，这个文件是32位的&lt;br/&gt; 2.分析程序搜索关键字符串error&lt;br/&gt; 判断语句在上方&lt;br/&gt; push为函数的开始，return为函数的结束&lt;br/&gt; --------- 代表函数的开始 因为不是很会汇编所以我利用IDA的F5功能把他编译成C语言&lt;br/&gt; 编译之前发现有两段花指令 花指令是程序中的无用代码，程序多它没影响，少了它也能正常运行。加花指令后，杀毒软件对木马静态反汇编时，木马的代码就不会正常显示出来，加大杀毒软件的查杀难度。&lt;br/&gt; 绕过花指令有两种方法&lt;br/&gt; 首先我们要设置Number of opcode bytes（操作码的字节数），我使用的是8 修改完之后就会出现以下情况&lt;br/&gt; 其中话指令说对应的就是E8 ，扰乱了反编译的过程 有两种绕过方式，分别在两条花指令中操作一、首先我们选中E8绕后打开Hex View 这样就可以定位到对应的地方&lt;br/&gt; F2 将他改成90 然后F2确认 我们发现E8改为90&lt;br/&gt; 后面的数据变正常了 90：是一个单独的指令，是一个什么都不做的指令 二、第二种方法我们选中E8的位置按u（undfine） 然后选择下面的66按c（code） 变成如下情况&lt;br/&gt; 就好像E8被注释掉了 花指令已经被我们绕过 我们选中整个函数从push开始到retn&lt;br/&gt; 按p&lt;br/&gt; 然后按F5 这是编译后的伪C 这一段应该简单的&lt;br/&gt; 上面是ascii码&lt;br/&gt; 我们把它转换回来 根据这个我们可以判断出来长度是4，第一位是1，第二位是5 后面两位我们继续往下看 我把四个字符串改为c1，c2，c3，c4 v10 = C3 - &apos;0&apos;; v0 = (double)v10; v10 = C1 - &apos;0&apos;; v1 = (double)v10; v10 = C2 - &apos;0&apos;; v2 = v1 / (double)v10; v10 = C4 - &apos;0&apos;; *(float *)&amp;v10 = (v0 - v2) * (double)v10 * 16.0; if ( *(float *)&amp;v10 != 384.0 ) 我这里列出了关键部分，其他语句没有什么意义的已知C1=1，C2=5 (c3-1/5)*c4*16.0=384.0 (c3-0.2)*c4==24.0 然后我们可以简单的穷举","path":"2018/07/12/WannaLOL2解题/"}]}