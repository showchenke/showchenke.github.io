{"pages":[],"posts":[{"title":"实验吧逆向破解课程学习笔记","text":"逆向破解的方法常用软件查壳软件PEID 脱壳软件lordPE、REC 逆向破解软件OD dede 查找按钮事件（地址） 1.暴力破解掌握利用字符串的方法破解程序 原理 利用登录时提供的关键字，找到关键跳转然后将关键跳转命令NOP掉。 方法 先黑盒测试 找到关键字，比如登录框中提供的错误提示 利用右键-&gt;中文搜索引擎-&gt;智能搜索 搜索到关键字false 然后双击关键字，跳转到汇编窗口false对应的哪一行 向上查找关键跳转（就是能够跳转到false语句）（je、jmp、jnz、je） 我们可以通过下断点测试 运行 输入账号密码 查看是否会实现跳转 右键二进制-&gt;用nop填充 复制到可执行文件-选择 保存到文件即可 2.获得注册码原理 利用登录时提供的关键字，找到关键字的call、下断点，单步试调追出注册码 方法 先黑盒测试 找到关键字，比如登录框中提供的错误提示 利用右键-&gt;中文搜索引擎-&gt;智能搜索 搜索到关键字 通过下断点，单步试调找到对应的用户名密码 3.跳转破解jmp：无条件跳转 利用软件登录时提供的关键字，找到关键跳转下断点 更改跳转命令，改变程序流程 空格键：编辑汇编指令 4.带壳破解加壳程序在载入OD时，现在入壳程序，然后有壳程序解密软件。 所以需要跳转到软件解密的地方搜索关键字符串，加密状态下是无法搜索到的 步骤：首先OD载入加壳软件 然后F9运行，使软件运行起来 然后ctrl+g，输入00401000（使软件跳转到程序解密的开始处，这样就可以搜索关键字了） 中文搜索引擎-&gt;智能搜索 之后的步骤就和常规的一样了 5.软件文件大小自校验利用ESP定律脱壳，然后OD把软件文件大小自校验NOP掉，软件正常运行 脱壳完成后还是无法打开软件，判断是软件大小自校验，脱壳后的文件会变大 接下来去除软件大小自校验 插件-&gt;APld断点设置工具0-&gt;常用断点设置-&gt;文件处理-&gt;GetFileSize F9运行到断点出 单击堆栈窗口-&gt;右键-&gt;在反汇编窗口中跟随 F2下断点 端机工具栏中的B，切换到断点窗口，删除getfilesize的断点 getfilesize函数获取了脱壳后的程序大小，然后利用cmp eax,0xc6c8 命令比较 我们把这条指令nop掉即可 6.修改关键call返回值利用软件登录时提供的关键字，找到关键call，改变关键call返回值，进而改变关键跳的流程 通过智能搜索字符串注册 双击定位到反汇编处，向上寻找关键跳转指令，发现吧je指令可以跳过注册，然后找到关键call，修改关键call，使得跳转实现 7.重启验证读取文件利用系统API函数下断点，解压软件，然后跳转到0401000处，查找关键字符串，找到关键跳转下断点，更改跳转命令，改变程序流程 8.万能断点万能断点就是把能下的断点都下一遍 利用万能断点追出注册码 万能断点：F3 A5 8B C8 83 E1 03 F3 A4 E8 单步步过追出注册码 9.VB弹出窗口掌握利用VB弹出函数追出软件内的注册码 在rtcMsgBox函数处下断点，然后追出账号和密码 运行程序输入错误的账号密码，然后单步步过找到关键跳转 10.删除弹窗掌握删除弹窗提示对话框的方法 f12暂停法直接到user32里了，K按钮进入堆栈页面 找到user32.MessageBoxExA，然后下断点 11.真码保存在系统文件运行程序找到关键字 通过关键字找到关键跳转，然后nop掉就可以了 12.BC++手动查找IATBC+被脱壳后需要手工修复ITA 使用ESP定律脱壳 OEP处手动寻找IAT，在jmp下的第一个call，按回车进入call寻找IAT 向上找到段首，右键》数据窗口中跟随》内存地址 然后早内存窗口中，右键长型》地址 0056E114 点击工具栏中的M切换到内存页面软件的基地址为00400000 计算出IAT地址为0016E114 在REC中修改OEP：14E0 RVA：16E114 保存报表 删除无效的指针 修正转储 13.利用dede查找按钮事件软件载入到dede中 单击过程，发现有三个按钮界面 选择按钮事件的段首分别为004046F0和0040479C 把软件载入到od，ctrl+g，给两处下断点 第一个断点没有到输入注册码的地方，删除断点继续运行 然后出入注册码，点击注册 向下寻找关键跳转然后nop掉就可以了 14.ALT+F9关键call追注册码掌握急用ALT+F9的方法找到MessageBox提示框，跳到用户空间，追寻正确的注册码 运行软件，当弹出注册失败框时，返回到OD界面，F12暂停 OD打开运行软件，点击注册输入注册码，出现失败弹窗 返回OD，F12暂停,然后菜单栏中，调试》按钮》执行到用户代码 然后单击确定，返回到用户代码处 15.加壳软件打补丁利用OD追出注册码 智能搜索已注册和未注册 点击已注册跳转到反汇编窗口 向上查找，发现有两个jmp跳过注册成功的提示 在向上寻找能跳过两个jmp的跳转，这就是关键跳转 打开注册机其他》标签》制作内存补丁 选择软件，然后添加修改地址为关键跳转的地址，长度为6，原始指令0F8489040000，修改地址为909090909090 16. 易语言窗体法利用二进制字符串FF 25查找易语言窗体 更改易语言主窗口弹出代码，使程序跳过注册窗口，直接弹出用户界面 17.易语言退出暗桩利用push窗体破解软件时，会遇到暗桩，删除暗桩，正常运行 用OD打开 设置API断点》进程函数》ExitProcess F9运行到断点处，上方有一个调用退出函数的call 再上面有一个可以跳过call 的跳转，把他改成jmp然后保存即可 18.VB按钮脚本破解掌握利用VB脚本下断点，找到关键关键跳转 利用脚本程序下断点，在断点出找到cmp*0xFFFF处，这个cmp比较命令下面的跳转为关键跳转 运行脚本（VB事件断点查找脚本） 然后运行程序，停在断点出 F8单步步过，向下查找有FFFF的命令，紧跟着的跳转就是关键跳转，设置断点，并删除其他断点 把刚才的跳转nop掉，然后Ctrl+g和上方ffff一样的命令，把下面的断点也nop掉 19. 修改软件标题图标PE Explorer修改软件标题信息 用PE Explorer打开软件，单击左侧的rc资源-&gt;TFRMTSFILTER 双击FrmTSFilter:TFrmTSFilter 单击caption然后再下面修改，然后单击应用即可","path":"2018/10/06/实验吧笔记/"},{"title":"Bugku逆向部分writeup","text":"##第一题 用ida打开浏览一下就可以看到flag .text:004023A5 loc_4023A5: ; CODE XREF: .text:00402391↑j .text:004023A5 mov eax, [ebp-18h] .text:004023A8 push eax .text:004023A9 push offset aMctfN3tRev1sE4 ; &quot;MCTF{_N3t_Rev_1s_E4ay_}&quot; .text:004023AE call ds:__vbaStrCmp .text:004023B4 mov edi, eax .text:004023B6 lea ecx, [ebp-18h] .text:004023B9 neg edi .text:004023BB sbb edi, edi .text:004023BD inc edi .text:004023BE neg edi ##第二题用OD打开右键》智能搜索》中文引擎搜索发现flag就在上面","path":"2018/10/03/bugkuwriteup/"},{"title":"WannaLOL2解题(详细)","text":"WannaLOL2解题1.黑盒测试运行文件，看看有什么效果&lt;br/&gt; 黑盒测试 输入，限制长度，控制，提示错误之类的&lt;br/&gt; 判断位数，32位/64位&lt;br/&gt; 可以通过IDA打开看看，64位只能打开64位的文件，32位只能打开32位的文件&lt;br/&gt; IDA7.0他会提示错误如果打开错误&lt;br/&gt; 这一栏也有提示，这个文件是32位的&lt;br/&gt; 2.分析程序搜索关键字符串error&lt;br/&gt; 判断语句在上方&lt;br/&gt; push为函数的开始，return为函数的结束&lt;br/&gt; --------- 代表函数的开始 因为不是很会汇编所以我利用IDA的F5功能把他编译成C语言&lt;br/&gt; 编译之前发现有两段花指令 花指令是程序中的无用代码，程序多它没影响，少了它也能正常运行。加花指令后，杀毒软件对木马静态反汇编时，木马的代码就不会正常显示出来，加大杀毒软件的查杀难度。&lt;br/&gt; 绕过花指令有两种方法&lt;br/&gt; 首先我们要设置Number of opcode bytes（操作码的字节数），我使用的是8 修改完之后就会出现以下情况&lt;br/&gt; 其中话指令说对应的就是E8 ，扰乱了反编译的过程 有两种绕过方式，分别在两条花指令中操作一、首先我们选中E8绕后打开Hex View 这样就可以定位到对应的地方&lt;br/&gt; F2 将他改成90 然后F2确认 我们发现E8改为90&lt;br/&gt; 后面的数据变正常了 90：是一个单独的指令，是一个什么都不做的指令 二、第二种方法我们选中E8的位置按u（undfine） 然后选择下面的66按c（code） 变成如下情况&lt;br/&gt; 就好像E8被注释掉了 花指令已经被我们绕过 我们选中整个函数从push开始到retn&lt;br/&gt; 按p&lt;br/&gt; 然后按F5 这是编译后的伪C 这一段应该简单的&lt;br/&gt; 上面是ascii码&lt;br/&gt; 我们把它转换回来 根据这个我们可以判断出来长度是4，第一位是1，第二位是5 后面两位我们继续往下看 我把四个字符串改为c1，c2，c3，c4 v10 = C3 - &apos;0&apos;; v0 = (double)v10; v10 = C1 - &apos;0&apos;; v1 = (double)v10; v10 = C2 - &apos;0&apos;; v2 = v1 / (double)v10; v10 = C4 - &apos;0&apos;; *(float *)&amp;v10 = (v0 - v2) * (double)v10 * 16.0; if ( *(float *)&amp;v10 != 384.0 ) 我这里列出了关键部分，其他语句没有什么意义的已知C1=1，C2=5 (c3-1/5)*c4*16.0=384.0 (c3-0.2)*c4==24.0 然后我们可以简单的穷举","path":"2018/07/12/123/"}]}